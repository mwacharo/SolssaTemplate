<?php

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use App\Models\Message;
use App\Models\User;
use App\Models\Client;
use Illuminate\Support\Facades\Log;
use App\Services\AIResponderService;
use App\Services\WhatsAppService;

class WhatsAppWebhookController extends Controller
{
    protected $whatsAppService;

    public function __construct(WhatsAppService $whatsAppService)
    {
        $this->whatsAppService = $whatsAppService;
    }

    public function handle(Request $request)
    {
        $payload = $request->all();
        Log::info('ğŸ”” WhatsApp Webhook Received', $payload);

        try {
            $type = $payload['typeWebhook'] ?? 'undefined';

            switch ($type) {
                case 'incomingMessageReceived':
                    return $this->handleIncomingMessage($payload);

                case 'outgoingMessageReceived':
                    return $this->handleOutgoing($payload);

                case 'outgoingMessageStatus':
                    return $this->handleStatusUpdate($payload);

                case 'stateInstanceChanged':
                    Log::info('âš™ï¸ Instance state changed', [
                        'state' => $payload['stateInstance'] ?? 'unknown'
                    ]);
                    break;

                default:
                    Log::warning("âš ï¸ Unhandled or unknown webhook type: {$type}", $payload);
                    break;
            }

            // return response()->json(['status' => 'received']);

                return response()->json(['status' => 'ok'], 200);

        } catch (\Throwable $e) {
            Log::error('âŒ Webhook error: ' . $e->getMessage(), [
                'trace' => $e->getTraceAsString(),
            ]);
            // return response()->json(['error' => 'Webhook processing failed'], 500);
            return response()->json(['message' => 'Message not found'], 200); // Return 200 anyway

        }
    }

    protected function handleIncomingMessage(array $payload)
    {
        $chatId   = data_get($payload, 'senderData.chatId');
        $senderId = data_get($payload, 'senderData.senderId');
        $text     = data_get($payload, 'messageData.textMessageData.textMessage');
        $quoted   = data_get($payload, 'messageData.quotedMessage.message');
        $quotedId = data_get($payload, 'messageData.quotedMessage.stanzaId');
        $type     = data_get($payload, 'messageData.typeMessage', 'textMessage');
        $timestamp = now();

        Log::info("ğŸ” Looking up client by chatId: {$chatId}");
        $user = $this->identifyClient($chatId);

        $recentOrders = [];

        if ($user) {
            Log::info("âœ… Client found: {$user->id}");
            $recentOrders = $user->orders()
                ->with(['orderItems', 'vendor', 'rider', 'agent', 'client'])
                ->latest()
                ->take(5)
                ->get();

            Log::info("ğŸ“¦ Recent orders fetched", $recentOrders->toArray());
        } else {
            Log::warning("ğŸš« No client found for chatId: {$chatId}");
        }

        try {
            $ai = new AIResponderService();
            Log::info("ğŸ¤– Interpreting customer query: {$text}");
            $reply = $ai->interpretCustomerQuery($text, is_array($recentOrders) ? $recentOrders : $recentOrders->toArray());
        } catch (\Throwable $e) {
            Log::error("âŒ AIResponderService error: " . $e->getMessage());
            $reply = null;
        }

        if ($reply) {
            Log::info("ğŸ“¤ Sending AI reply to {$chatId}: {$reply}");
            try {
                $this->whatsAppService->sendMessage($chatId, $reply, 1); // 1 = System user
            } catch (\Throwable $e) {
                Log::error("âŒ WhatsAppService error: " . $e->getMessage());
            }
        } else {
            Log::info("â„¹ï¸ No reply generated by AI for {$chatId}");
        }

        try {
            Message::create([
                'chat_id' => $chatId,
                'from' => $chatId,
                'to' => 'system',
                'content' => $text,
                'wa_message_id' => data_get($payload, 'idMessage'),
                'quoted_message_id' => $quotedId,
                'quoted_message_text' => $quoted,
                'type' => $type,
                'timestamp' => $timestamp,
                'messageable_type' => \App\Models\User::class,
                'messageable_id' => 1,
            ]);

            Log::info("ğŸ’¬ Message stored from {$chatId} at {$timestamp}");
        } catch (\Throwable $e) {
            Log::error("âŒ Failed to store message: " . $e->getMessage());
        }

        return response()->json(['status' => 'stored']);
    }

    protected function handleOutgoing(array $payload)
    {
        $chatId = data_get($payload, 'senderData.chatId');
        $senderId = data_get($payload, 'senderData.sender');
        $text = data_get($payload, 'messageData.textMessageData.textMessage');

        if (!$chatId || !$text) {
            return response()->json(['error' => 'Missing outgoing data'], 400);
        }

        Log::info("ğŸ” Identifying sender for chatId: {$senderId}");
        $sender = $this->identifySender($senderId);

        try {
            $msg = Message::updateOrCreate(
                ['external_message_id' => data_get($payload, 'idMessage')],
                [
                    'chat_id' => $chatId,
                    'from' => 'system',
                    'to' => $chatId,
                    'content' => $text,
                    'message_type' => data_get($payload, 'messageData.typeMessage', 'text'),
                    'timestamp' => now(),
                    'direction' => 'outgoing',
                    'message_status' => 'sent',
                    'messageable_type' => \App\Models\User::class,
                    'messageable_id' => $sender ? $sender->id : 1,
                ]
            );

            return response()->json(['status' => 'stored_outgoing', 'id' => $msg->id]);
        } catch (\Throwable $e) {
            Log::error("âŒ Failed to store outgoing message: " . $e->getMessage());
            // return response()->json(['error' => 'Failed to store outgoing'], 500);

                return response()->json(['message' => 'Message not found'], 200); // Return 200 anyway

        }
    }

    // protected function handleStatusUpdate(array $payload)
    // {
    //     $idMessage = data_get($payload, 'idMessage');
    //     $status = data_get($payload, 'status');

    //     if (!$idMessage || !$status) {
    //         return response()->json(['error' => 'Missing status data'], 400);
    //     }

    //     // Try both 'external_message_id' and 'wa_message_id'
    //     $msg = Message::where('external_message_id', $idMessage)
    //         ->orWhere('wa_message_id', $idMessage)
    //         ->first();

    //     if ($msg) {
    //         $msg->status = $status;
    //         $msg->timestamp = now();

    //         if ($status === 'delivered') {
    //             $msg->delivered_at = now();
    //         }

    //         if ($status === 'read') {
    //             $msg->read_at = now();
    //         }

    //         if ($status === 'failed') {
    //             $msg->failed_at = now();
    //         }

    //         $msg->save();

    //         return response()->json(['status' => 'updated', 'id' => $msg->id]);
    //     }

    //     Log::warning("âš ï¸ Status update received for unknown message ID: {$idMessage}");

    //     return response()->json(['warning' => 'Message not found'], 404);
    // }


    protected function handleStatusUpdate(array $payload)
{
    $idMessage = data_get($payload, 'idMessage');
    $status = data_get($payload, 'status');

    if (!$idMessage || !$status) {
        Log::warning("âŒ Missing status update data: ", $payload);
        return response()->json(['error' => 'Missing status data'], 200); // Return 200 anyway to satisfy Green API
    }

    $msg = Message::where('external_message_id', $idMessage)
        ->orWhere('wa_message_id', $idMessage)
        ->first();

    if ($msg) {
        $msg->status = $status;
        $msg->timestamp = now();

        if ($status === 'delivered') {
            $msg->delivered_at = now();
        }

        if ($status === 'read') {
            $msg->read_at = now();
        }

        if ($status === 'failed') {
            $msg->failed_at = now();
        }

        $msg->save();

        return response()->json(['status' => 'updated', 'id' => $msg->id], 200);
    }

    Log::warning("âš ï¸ Status update received for unknown message ID: {$idMessage}");

    // return response()->json(['warning' => 'Message not found'], 200); // Green API expects 200 regardless

        return response()->json(['message' => 'Message not found'], 200); // Return 200 anyway

}


    private function identifyClient($chatId)
    {
        $cleanChatId = preg_replace('/@.*$/', '', $chatId);
        $normalized = ltrim($cleanChatId, '0+');

        $client = Client::where('phone_number', 'like', "%{$normalized}")->first();
        if ($client) return $client;

        if (strlen($normalized) > 9 && str_starts_with($normalized, '254')) {
            $local = '0' . substr($normalized, 3);
            $client = Client::where('phone_number', $local)->first();
            if ($client) return $client;
        }

        return Client::where('phone_number', $cleanChatId)->first();
    }

    private function identifySender($senderId)
    {
        $cleanSenderId = preg_replace('/@.*$/', '', $senderId);
        $normalized = ltrim($cleanSenderId, '0+');

        $user = User::where('phone_number', 'like', "%{$normalized}")->first();
        if ($user) return $user;

        if (strlen($normalized) > 9 && str_starts_with($normalized, '254')) {
            $local = '0' . substr($normalized, 3);
            $user = User::where('phone_number', $local)->first();
            if ($user) return $user;
        }

        return User::where('phone_number', $cleanSenderId)->first();
    }
}
